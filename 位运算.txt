位运算
1.位与运算  & 
注意：& 和 && 是有区别的。前面这个是位与运算，后者是逻辑与运算，也就是算数运算

1 1 1 1  
0 1 0 1  
看看位与运算的真值表  结论：全真为真。其他为假
0 & 1    0
1 & 0    0
1 & 1    1
0 & 0    0

0x5b  5  0101
 
例如：
0xb5 & 0123      0x11
001101110
010101111
00000101110  02e

0x2c  & 0x2b     0x28
1100
1010     1000

2.位或运算
真值表
0 | 0  0

0 | 1  1

1 | 0  1

1 | 1  1

位或运算 （|）和逻辑或（||）区别

区别和上面的与类似 有1就为1

027 | 0x74 
0010 0111
0111 0101

0111 0111 0x77

0x1f  |  0xa5   0xbf

0x5f | 0x50    0x5f

3、位异或 （^）

真值表;
1 ^ 0   1
1 ^ 1   0
0 ^ 0   0
0 ^ 1   1

从真值表能得出结论：相同的就为0，不同的为1

异或就是相当于把两个相异的进行或操作

25 ^ 0263    b3

0x5f ^ 0xa4   0xfb
0101 1111
1010 0100    1111 1011  0xfb

0x47 & 0x38    0xa5 | 0x4f  0x14 ^ 0124

0x0   0xef   0x40 0x004  0xa8

000010100
001010100
0100 0000

4、位取反 ~
注意：在C语言中位取反是~，逻辑取反！
规则：把二进制数进行一个变化。1变成0，0变成1

总结：任何非0的数被逻辑取反在取反就会得到1；
    任何非0数被位取反在取反就会得到本身；

~0x5f    ~0124 ~47
0xa0     065    0x2b

总结：

5.左移动  <<  右移动 >>
在c语言中，进行位左移操作的时候要取决于数据类型
对于无符号数，左移时右侧补0
对于无符号数，右移动左侧补0；
对于有符号数， 左移动时右侧补0
对于有符号数，右移时左侧补符号位（如果是正数就补0，负数补1）；

在嵌入式中。在研究位移动，为了方便、快捷。我们规定移位都是无符号的数。

6.左移 <<

s数<< 多少位

0x54 <<2   
0101 0100    0101 0000    0x50

0xf4 <<1  0x6b<<6
0xe8      0xc0

7.右移
  
数>> 多少位

0x54 >>2  

01010100  


0xf4 >>4  0xd1 >>1
0x0f       0x68

升级：

0x17  bit2变成0
00010111     结果：00010011  0x13
&
11111011   取反：00000100  把1进行变化00000001  ~(1<<2) & 0x17


0001 1011  0x1b  bit2变成1；0001 1111

00011011
00000100  或运算  00011111
00000100  和00000001   (1<<2) | 0x1b   00011111
